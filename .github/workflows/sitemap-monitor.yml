name: Enhanced Sitemap Monitor & Status Reporter

on:
  push:
    branches: ["main", "master"]
  pull_request:
    branches: ["main", "master"]
  schedule:
    - cron: '0 12 * * 1' # Weekly on Mondays at 12:00 UTC
    - cron: '0 6 * * *'  # Daily health check at 6:00 UTC
  workflow_dispatch:
    inputs:
      force_resubmit:
        description: 'Force resubmit all sitemaps'
        required: false
        default: 'false'
        type: boolean
      detailed_report:
        description: 'Generate detailed status report'
        required: false
        default: 'true'
        type: boolean

jobs:
  sitemap-status-monitor:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install google-api-python-client google-auth-oauthlib google-auth-httplib2
          pip install requests beautifulsoup4 lxml tabulate colorama
          pip install python-dateutil pytz

      - name: Setup service account credentials
        run: |
          echo '${{ secrets.GOOGLE_SERVICE_ACCOUNT }}' | jq . > service-account.json
          chmod 600 service-account.json

      - name: Validate environment
        run: |
          echo "=== Environment Validation ==="
          python --version
          echo "Service account validation:"
          if python -c "import json; json.load(open('service-account.json'))" 2>/dev/null; then
            echo "✅ Service account JSON is valid"
          else
            echo "❌ Invalid service account JSON"
            exit 1
          fi

      - name: Create enhanced sitemap monitoring script
        run: |
          cat > enhanced_sitemap_monitor.py << 'EOF'
          #!/usr/bin/env python3
          import os, sys, json, argparse
          from datetime import datetime, timezone
          from typing import Dict, List, Tuple
          import requests
          import xml.etree.ElementTree as ET
          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          from googleapiclient.errors import HttpError

          class SitemapMonitor:
              def __init__(self, service_account_path: str):
                  self.service_account_path = service_account_path
                  self.service = None
                  self.site_url = None
                  self.results = {
                      'timestamp': datetime.now(timezone.utc).isoformat(),
                      'site_url': None,
                      'sitemaps': [],
                      'issues_found': [],
                      'fixes_applied': [],
                      'summary': {}
                  }

              def authenticate(self) -> bool:
                  try:
                      credentials = service_account.Credentials.from_service_account_file(
                          self.service_account_path,
                          scopes=['https://www.googleapis.com/auth/webmasters']
                      )
                      self.service = build('webmasters', 'v3', credentials=credentials)
                      print("✅ Authenticated with Google Search Console")
                      return True
                  except Exception as e:
                      print(f"❌ Authentication failed: {e}")
                      self.results['issues_found'].append(f"Authentication failed: {e}")
                      return False

              def validate_sitemap_url(self, sitemap_url: str) -> Tuple[bool, str]:
                  try:
                      response = requests.get(sitemap_url, timeout=30, headers={
                          'User-Agent': 'Googlebot/2.1 (+http://www.google.com/bot.html)'
                      })
                      if response.status_code != 200:
                          return False, f"HTTP {response.status_code}: {response.reason}"
                      try:
                          root = ET.fromstring(response.content)
                          if root.tag.endswith('sitemapindex') or root.tag.endswith('urlset'):
                              url_count = len(root.findall('.//{http://www.sitemaps.org/schemas/sitemap/0.9}url'))
                              sitemap_count = len(root.findall('.//{http://www.sitemaps.org/schemas/sitemap/0.9}sitemap'))
                              if url_count > 0:
                                  return True, f"Valid sitemap with {url_count} URLs"
                              elif sitemap_count > 0:
                                  return True, f"Valid sitemap index with {sitemap_count} sitemaps"
                              else:
                                  return False, "Sitemap contains no URLs"
                          else:
                              return False, "Not a valid sitemap format"
                      except ET.ParseError as e:
                          return False, f"XML parsing error: {e}"
                  except requests.RequestException as e:
                      return False, f"Request failed: {e}"

              def get_sitemap_status(self, site_url: str, sitemap_url: str) -> Dict:
                  try:
                      result = self.service.sitemaps().get(
                          siteUrl=site_url,
                          feedpath=sitemap_url
                      ).execute()
                      return {
                          'url': sitemap_url,
                          'status': 'submitted',
                          'errors': result.get('errors', 0),
                          'warnings': result.get('warnings', 0),
                          'isPending': result.get('isPending', False),
                          'lastDownloaded': result.get('lastDownloaded'),
                      }
                  except HttpError as e:
                      if e.resp.status == 404:
                          return {'url': sitemap_url, 'status': 'not_submitted', 'error': 'Not in GSC'}
                      else:
                          return {'url': sitemap_url, 'status': 'error', 'error': str(e)}

              def submit_sitemap(self, site_url: str, sitemap_url: str) -> bool:
                  try:
                      self.service.sitemaps().submit(siteUrl=site_url, feedpath=sitemap_url).execute()
                      self.results['fixes_applied'].append(f"Submitted {sitemap_url}")
                      return True
                  except HttpError as e:
                      self.results['issues_found'].append(f"Submit failed: {e}")
                      return False

              def monitor_sitemaps(self, site_url: str, sitemap_urls: List[str], force_resubmit: bool = False):
                  self.site_url = site_url
                  self.results['site_url'] = site_url
                  if not self.authenticate(): return self.results

                  for sitemap_url in sitemap_urls:
                      valid, msg = self.validate_sitemap_url(sitemap_url)
                      entry = {'url': sitemap_url, 'validation': {'is_valid': valid, 'message': msg}}
                      if not valid:
                          entry['status'] = 'validation_failed'
                          self.results['issues_found'].append(f"Validation failed {sitemap_url}: {msg}")
                      else:
                          status = self.get_sitemap_status(site_url, sitemap_url)
                          entry.update(status)
                          if status['status'] == 'not_submitted' or force_resubmit:
                              if self.submit_sitemap(site_url, sitemap_url):
                                  entry['action'] = 'submitted'
                          elif status['status'] == 'submitted' and status['errors'] > 0:
                              self.submit_sitemap(site_url, sitemap_url)
                              entry['action'] = f're-submitted (errors={status["errors"]})'
                          else:
                              entry['action'] = 'healthy'
                      self.results['sitemaps'].append(entry)

                  self.results['summary'] = {
                      'total_sitemaps': len(self.results['sitemaps']),
                      'issues_found': len(self.results['issues_found']),
                      'fixes_applied': len(self.results['fixes_applied']),
                      'overall_status': 'healthy' if not self.results['issues_found'] else 'issues_detected'
                  }
                  return self.results

              def generate_report(self, detailed=True):
                  s = self.results['summary']
                  report = [f"# Sitemap Report", f"Generated: {self.results['timestamp']}", ""]
                  report.append(f"## Status: {s['overall_status'].upper()}")
                  report.append(f"- Total sitemaps: {s['total_sitemaps']}")
                  report.append(f"- Issues found: {s['issues_found']}")
                  report.append(f"- Fixes applied: {s['fixes_applied']}")
                  if detailed:
                      for sm in self.results['sitemaps']:
                          report.append(f"### {sm['url']}")
                          report.append(f"Status: {sm.get('status')}")
                          report.append(f"Action: {sm.get('action')}")
                  return "\n".join(report)

          def main():
              p = argparse.ArgumentParser()
              p.add_argument('--site', required=True)
              p.add_argument('--sitemaps', required=True, nargs='+')
              p.add_argument('--force-resubmit', action='store_true')
              p.add_argument('--detailed-report', dest='detailed_report', action='store_true')
              p.add_argument('--no-detailed-report', dest='detailed_report', action='store_false')
              p.set_defaults(detailed_report=True)
              p.add_argument('--service-account', default='service-account.json')
              p.add_argument('--output-json')
              p.add_argument('--output-report')
              a = p.parse_args()

              monitor = SitemapMonitor(a.service_account)
              results = monitor.monitor_sitemaps(a.site, a.sitemaps, a.force_resubmit)
              if a.output_json:
                  with open(a.output_json, 'w') as f: json.dump(results, f, indent=2)
              report = monitor.generate_report(a.detailed_report)
              if a.output_report:
                  with open(a.output_report, 'w') as f: f.write(report)
              print(report)
              sys.exit(0 if results['summary']['overall_status'] == 'healthy' else 1)

          if __name__ == "__main__": main()
          EOF

      - name: Run Enhanced Sitemap Monitor
        id: sitemap_check
        run: |
          python enhanced_sitemap_monitor.py \
            --site "https://sednabcn.github.io/" \
            --sitemaps "https://sednabcn.github.io/sitemap.xml" \
            --output-json "sitemap-results.json" \
            --output-report "sitemap-report.md" \
            ${{ inputs.force_resubmit == 'true' && '--force-resubmit' || '' }} \
            ${{ inputs.detailed_report == 'false' && '--no-detailed-report' || '--detailed-report' }}
        continue-on-error: true

      - name: Upload Results as Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: sitemap-monitor-results-${{ github.run_number }}
          path: |
            sitemap-results.json
            sitemap-report.md
          retention-days: 30

      - name: Check Results and Set Status
        id: check_results
        run: |
          if [ -f "sitemap-results.json" ]; then
            ISSUES_COUNT=$(python -c "import json; d=json.load(open('sitemap-results.json')); print(d['summary']['issues_found'])")
            FIXES_COUNT=$(python -c "import json; d=json.load(open('sitemap-results.json')); print(d['summary']['fixes_applied'])")
            OVERALL_STATUS=$(python -c "import json; d=json.load(open('sitemap-results.json')); print(d['summary']['overall_status'])")
            echo "issues_count=$ISSUES_COUNT" >> $GITHUB_OUTPUT
            echo "fixes_count=$FIXES_COUNT" >> $GITHUB_OUTPUT
            echo "overall_status=$OVERALL_STATUS" >> $GITHUB_OUTPUT
            if [ "$OVERALL_STATUS" = "healthy" ]; then
              echo "status_emoji=✅" >> $GITHUB_OUTPUT
              echo "status_message=All sitemaps healthy" >> $GITHUB_OUTPUT
            else
              echo "status_emoji=❌" >> $GITHUB_OUTPUT
              echo "status_message=Issues detected - check report" >> $GITHUB_OUTPUT
            fi
          else
            echo "status_emoji=💥" >> $GITHUB_OUTPUT
            echo "status_message=Monitor script failed" >> $GITHUB_OUTPUT
            echo "issues_count=1" >> $GITHUB_OUTPUT
            echo "fixes_count=0" >> $GITHUB_OUTPUT
            echo "overall_status=error" >> $GITHUB_OUTPUT
          fi

      - name: Create or Update Issue on Problems
        if: steps.check_results.outputs.overall_status != 'healthy'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const issueTitle = '🗺️ Sitemap Monitor: Issues Detected';
            let reportContent = 'Report generation failed.';
            try { reportContent = fs.readFileSync('sitemap-report.md', 'utf8'); } catch {}

            const issueBody = reportContent + '\n\n**Workflow Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})' + 
'\n**Triggered by:** ${{ github.event_name }}' +
'\n**Issues Found:** ${{ steps.check_results.outputs.issues_count }}' +
'\n**Fixes Applied:** ${{ steps.check_results.outputs.fixes_applied }}';

_Automatically created by the Enhanced Sitemap Monitor workflow._`;

            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner, repo: context.repo.repo, state: 'open', labels: ['sitemap-monitor','automated']
            });
            const existing = issues.data.find(i => i.title === issueTitle);
            if (existing) {
              await github.rest.issues.update({ owner: context.repo.owner, repo: context.repo.repo, issue_number: existing.number, body: issueBody });
            } else {
              await github.rest.issues.create({ owner: context.repo.owner, repo: context.repo.repo, title: issueTitle, body: issueBody, labels: ['sitemap-monitor','automated','bug'] });
            }

      - name: Close Issue if All Healthy
        if: steps.check_results.outputs.overall_status == 'healthy'
        uses: actions/github-script@v6
        with:
          script: |
            const issueTitle = '🗺️ Sitemap Monitor: Issues Detected';
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner, repo: context.repo.repo, state: 'open', labels: ['sitemap-monitor','automated']
            });
            const existing = issues.data.find(i => i.title === issueTitle);
            if (existing) {
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: existing.number,
                body: `✅ All sitemap issues resolved!\n\nRun: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
              });
              await github.rest.issues.update({ owner: context.repo.owner, repo: context.repo.repo, issue_number: existing.number, state: 'closed' });
            }

      - name: Update Repository Status Badge
        run: |
          mkdir -p .github/badges
          STATUS_MESSAGE="${{ steps.check_results.outputs.status_message }}"
          if [ "${{ steps.check_results.outputs.overall_status }}" = "healthy" ]; then
            COLOR="brightgreen"
          else
            COLOR="red"
          fi
          cat > .github/badges/sitemap-status.json <<EOF
          {
            "schemaVersion": 1,
            "label": "sitemap status",
            "message": "$STATUS_MESSAGE",
            "color": "$COLOR",
            "namedLogo": "google",
            "logoColor": "white"
          }
          EOF

      - name: Commit Status Updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .github/badges/sitemap-status.json || true
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "🗺️ Update sitemap status badge - ${{ steps.check_results.outputs.status_message }}"
            git push
          fi

      - name: Summary
        run: |
          echo "## 🗺️ Sitemap Monitor Summary" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.check_results.outputs.status_emoji }} **Status:** ${{ steps.check_results.outputs.status_message }}" >> $GITHUB_STEP_SUMMARY
          echo "- Issues Found: ${{ steps.check_results.outputs.issues_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- Fixes Applied: ${{ steps.check_results.outputs.fixes_count }}" >> $GITHUB_STEP_SUMMARY
          if [ -f "sitemap-report.md" ]; then
            echo "### 📋 Detailed Report" >> $GITHUB_STEP_SUMMARY
            cat sitemap-report.md >> $GITHUB_STEP_SUMMARY
          fi

      - name: Send Slack Notification (if configured)
        if: steps.check_results.outputs.overall_status != 'healthy'
        run: |
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\":\"🗺️ Sitemap Monitor Alert\",\"attachments\":[{\"color\":\"danger\",\"fields\":[{\"title\":\"Status\",\"value\":\"${{ steps.check_results.outputs.status_message }}\",\"short\":true},{\"title\":\"Issues Found\",\"value\":\"${{ steps.check_results.outputs.issues_count }}\",\"short\":true},{\"title\":\"Workflow\",\"value\":\"<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>\",\"short\":false}]}]}" \
              "${{ secrets.SLACK_WEBHOOK_URL }}"
          else
            echo "No Slack webhook configured"
          fi
